---
layout: post
title:  第115期
---
# C++ 中文周刊 第115期


[周刊项目地址](https://github.com/wanghenshui/cppweeklynews)

公众号

<img src="https://wanghenshui.github.io/cppweeklynews/assets/code.png" alt=""  width="30%">



RSS https://github.com/wanghenshui/cppweeklynews/releases.atom

欢迎投稿，推荐或自荐文章/软件/资源等

请[提交 issue](https://github.com/wanghenshui/cppweeklynews/issues)


---

## 资讯

标准委员会动态/ide/编译器信息放在这里

[编译器信息最新动态推荐关注hellogcc公众号 本周更新 2023-01-04 第183期](https://github.com/hellogcc/osdt-weekly/blob/master/weekly-2023/2023-01-04.md)

五月邮件列表 https://isocpp.org/blog/2023/05/2023-05-mailing-available

## 文章

- [Did you about C++17 std::index_sequence, std::make_index_sequence? ](https://github.com/QuantlabFinancial/cpp_tip_of_the_week/)

```cpp
template <class...> struct whats_my_type;
int main() { whats_my_type<std::make_index_sequence<7>>{}; } 
// error: implicit instantiation of undefined template 
// ‘whats_my_type<std::integer_sequence<unsigned long, 0, 1, 2, 3, 4, 5, 6>’<source>:8:3: error: implicit instantiation of undefined template ‘whats_my_type<std::integer_sequence<unsigned long, 0, 1, 2, 3, 4, 5, 6>’
```
这玩意还是挺有用的

- [Speeding up the insertion of a sorted (or mostly-sorted) key list into a std::map or other ordered associative container](https://devblogs.microsoft.com/oldnewthing/20230522-00/?p=108226)

如果key已经是排好序的，插入可以O1
```cpp
// Amortized linear overall insertion time if the range is sorted by key
// or reverse sorted by key. Performance degrades toward O(n log n) the more
// the list is not sorted.
template<typename C, typename Iterator>
auto try_emplace_mostly_sorted(C&& c, Iterator first, Iterator last)
    -> decltype(c.end())
{
    auto prev = c.end();
    for (; first != last; ++first) {
        prev = c.try_emplace(prev, first->key, first->value);
    }
    return prev;
}
```

llvm实现在这里，感兴趣的可以看看

https://github.com/llvm/llvm-project/blob/387c49f693c82bdf8b9b0f1ef48a92f51bb781b4/libcxx/include/__tree#L2027

- [C++23: Even more constexpr](https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr)

新的编译器对constexpr放松要求，比如

```cpp
#if __cpp_lib_optional >= 202106
constexpr
#endif
char xdigit(int n) {
  static constexpr char digits[] = "0123456789abcdef";
  return digits[n];
}
```

另外就是
`optional` `unique_ptr` `variant`,

`<cmath>` `<cstdlib>` 

`std::to_chars()` `std::from_chars()`  

以及`constexpr new/delete`

都支持constexpr


- []()


```cpp
  template <typename BitType, typename std::enable_if<FlagTraits<BitType>::isBitmask, bool>::type = true>
  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR Flags<BitType> operator|( BitType lhs, BitType rhs ) VULKAN_HPP_NOEXCEPT
  {
    return Flags<BitType>( lhs ) | rhs;
  }
```


- [What's the right hash table API?](https://brevzin.github.io/c++/2023/05/23/map-api/)

手把手教你如何优化哈希表的API

**优化find** find经常会有一个检查iter的动作，非常多余，如果直接返回`Optional<Value const&>`，并且支持`value_or`，就干净的多
```cpp
auto find(Key const&) -> iterator;
auto find(Key const&) -> Optional<pair<Key const, Value>&>;
auto find(Key const&) -> Optional<Value&>;
auto find(Key const&) -> Value;

```
但是find接口太多了。作者给了个特化建议

```cpp
struct return_element {
    template <input_iterator I>
    static auto from_value(I const& it) -> Optional<iter_reference_t<I>> {
        return *it;
    }

    template <input_iterator I>
    static auto from_end(I const&) -> Optional<iter_reference_t<I>> {
        return {};
    }
};

struct return_value {
    template <input_iterator I>
    static auto from_value(I const& it) -> Optional<decltype(it->second)> {
        return it->second;
    }

    template <input_iterator I>
    static auto from_end(I const&) -> Optional<decltype(it->second)> {
        return {};
    }
};

struct return_value_or_zero {
    template <input_iterator I>
    static auto from_value(I const& it) -> decltype(auto(it->second))
        return it->second;
    }

    template <input_iterator I>
    static auto from_end(I const&) -> decltype(auto(it->second))
        return {};
    }
};
auto a = map.find(key);                        // iterator
auto b = map.find<return_element>(key);        // Optional<pair<Key const, Value>&>
auto c = map.find<return_value>(key);          // Optional<Value&>
auto d = map.find<return_value_or_zero>(key);  // Value

```
**优化insert**

insert可能不成功，所以需要推迟value构造

```cpp
template <class F>
struct lazy_call {
    F f;

    template <class T> operator T() { return f(); }
};

#define LAZY(expr) lazy_call{[&]{ return expr; }}
auto [iter, success] = map.try_emplace(key, LAZY(acquire_value()));

```

这个思路还是很有用的

- [Don’t name your header file security.h either](https://devblogs.microsoft.com/oldnewthing/20230524-00/?p=108239)

windows总是有这种稀奇古怪的错误，类似的有 [shouldn’t name your DLL “security.dll](https://devblogs.microsoft.com/oldnewthing/20040702-00/?p=38583)

- [A deduction guide for Foo(Ts..., Ts...)](https://quuxplusone.github.io/blog/2023/05/26/metaprogramming-halfmap/)

问题，给这个类写CTAD推导指引

```cpp
template<class... Ts>
class Foo {
public:
  explicit Foo(Ts... as, Ts... bs) :
    a_(static_cast<Ts&&>(as)...),
    b_(static_cast<Ts&&>(bs)...) {}

private:
  std::tuple<Ts...> a_;
  std::tuple<Ts...> b_;
};
```

答案是当前还实现不了。。。不过可以实现一个make_foo
## 视频

- [C++ Weekly ](https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw)

`TODO fix link then remove this line`

## 开源项目需要人手

- [asteria](https://github.com/lhmouse/asteria) 一个脚本语言，可嵌入，长期找人，希望胖友们帮帮忙，也可以加群384042845和作者对线
- [Unilang](https://github.com/linuxdeepin/unilang) deepin的一个通用编程语言，点子有点意思，也缺人，感兴趣的可以github讨论区或者deepin论坛看一看。这里也挂着长期推荐了

## 新项目介绍/版本更新

## 工作招聘

---



[本文永久链接](https://wanghenshui.github.io/cppweeklynews/posts/115.html)

如果有疑问评论最好在上面链接到评论区里评论，这样方便搜索，微信公众号有点封闭/知乎吞评论
