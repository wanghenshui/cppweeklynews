---
layout: post
title:  第97期
---
# C++ 中文周刊 第97期


[周刊项目地址](https://github.com/wanghenshui/cppweeklynews)

公众号

<img src="https://wanghenshui.github.io/cppweeklynews/assets/code.png" alt=""  width="30%">

弄了个qq频道，[手机qq点击进入](https://qun.qq.com/qqweb/qunpro/share?_wv=3&_wwv=128&inviteCode=xzjHQ&from=246610&biz=ka)

RSS https://github.com/wanghenshui/cppweeklynews/releases.atom

欢迎投稿，推荐或自荐文章/软件/资源等

请[提交 issue](https://github.com/wanghenshui/cppweeklynews/issues)


---

## 资讯

标准委员会动态/ide/编译器信息放在这里

一月邮件列表

https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/#mailing2023-01

[编译器信息最新动态推荐关注hellogcc公众号 本周更新 2023-01-04 第183期](https://github.com/hellogcc/osdt-weekly/blob/master/weekly-2023/2023-01-04.md)

`TODO fix link then remove this line`

## 文章

- [c++ tip of week ](https://github.com/QuantlabFinancial/cpp_tip_of_the_week/)

`TODO fix link then remove this line`

- [ Poor man's introspection with #embed](https://twitter.com/krisjusiak/status/1615086312767516672)

笑死 `#embed` 早晚玩出花来

https://godbolt.org/z/Tj6c7jz1o


```cpp
#include <string_view>
#include <array>

template <std::size_t N>
struct fixed_string final {
    constexpr explicit(true) fixed_string(const auto... cs) : data{cs...} {}

    constexpr explicit(false) fixed_string(const char (&str)[N + 1]) {
        std::copy_n(str, N + 1, std::data(data));
    }

    [[nodiscard]] constexpr auto operator<=>(const fixed_string&) const =
        default;

    [[nodiscard]] constexpr explicit(false) operator std::string_view() const {
        return {std::data(data), N};
    }

    [[nodiscard]] constexpr auto size() const -> std::size_t { return N; }

    std::array<char, N + 1> data{};
};

template <std::size_t N>
fixed_string(const char (&str)[N]) -> fixed_string<N - 1>;
fixed_string(const auto... Cs) -> fixed_string<sizeof...(Cs)>;

template<fixed_string Name>
constexpr auto meta_contains = [] {
  static constexpr char self[] = { 
    #embed __FILE__ 
  };
  const auto code = std::string_view(std::data(self), std::size(self));
  const auto find = code.find(Name);
  return find != std::string_view::npos and code[find-1] != '\"';
}();

struct foo {};
struct bar {};

auto fn() -> void;

static_assert(not meta_contains<"struct x">);
static_assert(not meta_contains<"STD::string_view">);
static_assert(meta_contains<"std::string_view">);
static_assert(meta_contains<"struct foo">);
static_assert(meta_contains<"struct bar">);
static_assert(meta_contains<"auto fn()">);
```

- [How to make chunks of a range in C++23](https://mariusbancila.ro/blog/2023/01/16/how-to-make-chunks-of-a-range-in-cpp23/)

再学点range

adjacent

```cpp
std::vector v = { 1, 2, 3, 4, 5, 6, 7, 8 };
for (auto const& t : v | std::views::adjacent<3>) {
   std::cout << '[' << std::get<0>(t) << ',' 
                    << std::get<1>(t) << ',' 
                    << std::get<2>(t) 
             << ']' << '\n';
} 
/*
[1,2,3]
[2,3,4]
[3,4,5]
[4,5,6]
[5,6,7]
[6,7,8]
*/

//也可以这样

for (auto const& [a,b,c] : v | std::views::adjacent<3>) {
   std::cout << '[' << a << ',' << b << ',' << c << ']' << '\n';
}
```

slide和adjacent差不多，代码贴一下

```cpp
auto print(R&& r) {
   std::cout << '[';
   bool first = true;
   for (auto const e : r) {
      if(first) first = false;
      else std::cout << ',';
       
      std::cout << e;
   }
   std::cout << ']' << '\n';
}
std::vector v = { 1, 2, 3, 4, 5, 6, 7, 8 };
for (auto const& c : v | std::views::slide(3)) {
   print(c);
}

/*
[1,2,3]
[2,3,4]
[3,4,5]
[4,5,6]
[5,6,7]
[6,7,8]
*/
```
chunk，分段

```cpp
for (auto const& c : v | std::views::chunk(3)) {
   print(c);
}
/*
[1,2,3]
[4,5,6]
[7,8]
*/
```
chunk_by类似chunk，能提供一个谓词判断

```cpp
bool differ_by_one(int const a, int const b)
{
    return std::abs(a - b) <= 1;
}
std::vector v = {1,1,2,3,2,2,1,3,4,8,7,6,7};
for (auto const& c : v | std::views::chunk_by(differ_by_one))
{
   print(c);
}
/* 按照相邻差1来分段 
[1,1,2,3,2,2,1]
[3,4]
[8,7,6,7]
*/
```

再来个例子

```cpp
bool same_kind(char const a, char const b)
{
    bool b1 = std::isdigit(a);
    bool b2 = std::isdigit(b);
    return (b1 && b2) || (!b1 && !b2);
}
std::string s {"1234abc56e789fghi"};
for (auto const& c : s | std::views::chunk_by(same_kind))
{
   print(c);
}
/*
按照字母类型来分段

[1,2,3,4]
[a,b,c]
[5,6]
[e]
[7,8,9]
[f,g,h,i]

*/
```

- [Argument-Dependent Lookup and the Hidden Friend Idiom](https://www.modernescpp.com/index.php/argument-dependent-lookup-and-hidden-friends)

```cpp
#include <iostream>
class MyDistance{
 public:
    explicit MyDistance(double i):m(i){}
    friend MyDistance operator +(const MyDistance& a, const MyDistance& b){         // (1)
        return MyDistance(a.m + b.m);
    } 
    friend MyDistance operator -(const MyDistance& a, const MyDistance& b){         // (2)
        return MyDistance(a.m - b.m);
    }
    friend std::ostream& operator<< (std::ostream &out, const MyDistance& myDist){  // (3)
        out << myDist.m << " m";
        return out;
    }  
 private:
    double m;
};

int main() {
    std::cout << "MyDistance(5.5) + MyDistance(5.5): " << MyDistance(5.5) + MyDistance(5.5) << '\n';  // (4)
    std::cout << "MyDistance(5.5) - MyDistance(5.5): " << MyDistance(5.5) - MyDistance(5.5) << '\n';  // (5)
}
```

没啥说的，没有friend就找不到这几个operator函数，而且这么写也不用非得是成员函数

- [Falsehoods programmers believe about undefined behavior](https://pvs-studio.com/en/blog/posts/cpp/1024/)

好像之前说过这个？反复强调，undefined behavior未定义行为不等于实现定义，有可能是历史遗留问题，也有可能就毁灭地球

- [P1967 #embed and D2752 “Static storage for initializer_list” are now on Compiler Explorer](https://quuxplusone.github.io/blog/2023/01/13/embed-and-initializer-lists/)

逆天用法
```cpp
std::vector<unsigned char> getFavicon() {
  return {
    #embed "favicon.ico"
  };
}
这种场景embed可能退化成initializer_list，复制到栈上，然后再复制到vector，堆上，白白浪费

`#embed`就老老实实当属性二进制用，这种写法也不是不行，字符串不大也可以

作者写了个提案，方便解决这种情况。具体没看，大概就是识别优化掉这玩意
```
## 视频

- [C++ Weekly ](https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw)

`TODO fix link then remove this line`

## 开源项目需要人手

- [asteria](https://github.com/lhmouse/asteria) 一个脚本语言，可嵌入，长期找人，希望胖友们帮帮忙，也可以加群384042845和作者对线
- [pika](https://github.com/OpenAtomFoundation/pika) 一个nosql 存储， redis over rocksdb，非常需要人贡献代码胖友们， 感兴趣的欢迎加群294254078前来对线

## 新项目介绍/版本更新

- [svmegn](https://github.com/bloomen/svmegn) 用eigen封装svm接口
- [aedis](https://github.com/mzimbres/aedis) 要进boost
- [blaze / HPX Parallelization ](https://bitbucket.org/blaze-lib/blaze/wiki/HPX%20Parallelization) 不懂
- [snitch Lightweight C++20 testing framework.](https://github.com/cschreib/snitch)

---

看到这里或许你有建议或者疑问或者指出错误，请留言评论! 多谢!  你的评论非常重要！也可以帮忙点赞收藏转发！多谢支持！

[本文永久链接](https://wanghenshui.github.io/cppweeklynews/posts/097.html)

如果有疑问评论最好在上面链接到评论区里评论，这样方便搜索，微信公众号有点封闭/知乎吞评论
