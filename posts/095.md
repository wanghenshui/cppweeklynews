---
layout: post
title:  第95期
---
# C++ 中文周刊 第95期



[周刊项目地址](https://github.com/wanghenshui/cppweeklynews)

公众号

<img src="https://wanghenshui.github.io/cppweeklynews/assets/code.png" alt=""  width="30%">

弄了个qq频道，[手机qq点击进入](https://qun.qq.com/qqweb/qunpro/share?_wv=3&_wwv=128&inviteCode=xzjHQ&from=246610&biz=ka)

欢迎投稿，推荐或自荐文章/软件/资源等

请[提交 issue](https://github.com/wanghenshui/cppweeklynews/issues)

新年第一周

---

## 资讯

标准委员会动态/ide/编译器信息放在这里

[编译器信息最新动态推荐关注hellogcc公众号 本周更新 2022-01-05 第131期](https://github.com/hellogcc/osdt-weekly/blob/master/weekly-2022/2022-01-05.md)

`TODO fix link then remove this line`


## 文章

- [编程求一个正整数有几位，最快的方法是什么？](https://www.zhihu.com/question/566834458/answer/2767218099)

`__builtin_clzll`.作者还讲了一些优化的东西，涨涨见识

- [C++ at the end of 2022 ](https://www.cppstories.com/2022/cpp-status-2022/)

总结了2022年来c++的各种进展，很全面了

- [Did you know that C+23 permitts static constexpr variables in constexpr functions? ](https://github.com/QuantlabFinancial/cpp_tip_of_the_week/blob/master/tips/310.md)

直接看代码
```cpp
constexpr auto foo() {
  static constexpr auto value = 42; // error in C++20, okay in C++23
  return value;
}
```
乍看没啥用

给个例子

```cpp
template<char... Cs>
[[nodiscard]] constexpr auto to_string_view(){
    static constexpr char p[sizeof...(Cs)] = {Cs...};
    return std::string_view(p, sizeof...(Cs));
}
```

我发现这个特性和例子差距有点像`你已经学会1+1=2了来证明黎曼猜想吧`那种感觉

- [Did you know DRY (Don’t Repeat Yourself) comparisons pattern?](https://github.com/QuantlabFinancial/cpp_tip_of_the_week/blob/master/tips/311.md)

实现条件判断版本的none of any of


```cpp
auto none_of(auto pred, auto... ts) {
    const auto a = std::array{ts...};
    return std::none_of(std::cbegin(a), std::cend(a), pred);
}

auto before(int a, int b, int c) {
    if (a != 2 and b != 2 and c != 2) {
      return 42;
    }
    return 0;
}

auto after(int a, int b, int c) {
    if (none_of([](auto x) { return x == 2; }, a, b, c)) {
      return 42;
    }
    return 0;
}
```

anyof怎么实现？

```cpp
#include <utility>
#include <tuple>
#include <concepts>

template<class ... Args>
struct Comp {
    template<class T>
    auto operator==(T && other) {
        return std::apply(
            [&other](auto &&... data) {
                return (((std::equality_comparable_with<decltype(data), T>) && data == other) || ...);
            },
            this -> data
        );
    }
    std::tuple<Args...> data {};
};

template<class ...Args>
auto any_of(Args && ... args)  {
    return Comp<Args...> {
        std::make_tuple(std::forward<Args>(args)...)
    };
    
}
```

和上面差距有点大

- [Adding Design-by-Contract [[invariant]] conditions to C++, via a GCC plugin](https://gavinray97.github.io/blog/adding-invariant-to-cpp-design-by-contract)\

实现了一个gcc插件支持`[[invariant]]`特性，代码在这里https://github.com/GavinRay97/gcc-invariant-plugin

博客记录了开发插件的方法和过程，挺有意思的 

- [Debugging binaries invoked from scripts with GDB](https://developers.redhat.com/articles/2022/12/27/debugging-binaries-invoked-scripts-gdb#)

gdb调试和shell交互，复杂

- [Cpp2 and cppfront: Year-end mini-update](https://herbsutter.com/2022/12/31/cpp2-and-cppfront-year-end-mini-update/)

介绍他的折腾

- [Parallelizing C++ using Execution Policies](https://azeemba.com/posts/cpp17-execution-policy.html)

就是`std::execution::par`/`std::execution::par_unseq`这玩意

```cpp
std::vector<size_t> indices(num_pixels);
 // initialize indices with 0, 1, ..
std::iota(indices.begin(), indices.end(), 0); // needs <numeric>

std::transform( // needs <algorithm>
    std::execution::par, // <-- needs <execution>
    indices.begin(), indices.end(), pixels.begin(), 
    [](size_t index){
        return expensive_calculation(index);
    }
);
```
- [5 techniques for writing memory safe C++](https://www.embedded.com/5-techniques-for-writing-memory-safe-c/)

老生常谈讲智能指针那套东西

- []()

检查有没有std::hash特化

```cpp
struct HasStdHash {
private:
  template <class T, class Dummy = decltype(std::hash<T>{})>
  static constexpr bool exists(int) {
    return true;
  }

  template <class T>
  static constexpr bool exists(char) {
    return false;
  }

public:
  template <class T>
  static constexpr bool check() {
    return exists<T>(42);
  }
};

std::cout << "Does std::string have std::hash? " << HasStdHash::check<std::string>();
```

能不能更泛化一点？

```cpp
template <template <class... InnerArgs> class Tmpl>
struct IsSpecialized {
private:
  template <class... Args,
          class dummy = decltype(Tmpl<Args...>{}.~Tmpl<Args...>())>
  static constexpr bool exists(int) {
    return true;
  }

  template <class... Args>
  static constexpr bool exists(char) {
    return false;
  }

public:
  template <class... Args>
  static constexpr bool check() {
    return exists<Args...>(42);
  }
};
```

但这个代码对于这种场景是无效的
```cpp
template<class T> struct SomeStruct;
bool test1 = IsSpecialized<SomeStruct>::check<std::string>();

template<> struct SomeStruct<std::string> {};
bool test2 = IsSpecialized<SomeStruct>::check<std::string>();
```

后面又讨论了一通ADL检测，我已经看不懂了

- [Pro TBB阅读笔记（一](https://zhuanlan.zhihu.com/p/594746223)

随便看看

## 视频



## 开源项目需要人手

- [asteria](https://github.com/lhmouse/asteria) 一个脚本语言，可嵌入，长期找人，希望胖友们帮帮忙，也可以加群384042845和作者对线
- [pika](https://github.com/OpenAtomFoundation/pika) 一个nosql 存储， redis over rocksdb，非常需要人贡献代码胖友们， 感兴趣的欢迎加群294254078前来对线

## 新项目介绍/版本更新

- [bitset2: bitset improved](https://github.com/ClaasBontus/bitset2) 给标准库的bitset做了很多调优和加强

---

看到这里或许你有建议或者疑问或者指出错误，请留言评论! 多谢!  你的评论非常重要！也可以帮忙点赞收藏转发！多谢支持！

[本文永久链接](https://wanghenshui.github.io/cppweeklynews/posts/095.html)
