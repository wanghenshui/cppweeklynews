---
layout: post
title:  第126期
---
# C++ 中文周刊 第126期


[周刊项目地址](https://github.com/wanghenshui/cppweeklynews)

公众号

<img src="https://wanghenshui.github.io/cppweeklynews/assets/code.png" alt=""  width="30%">



RSS https://github.com/wanghenshui/cppweeklynews/releases.atom

欢迎投稿，推荐或自荐文章/软件/资源等

请[提交 issue](https://github.com/wanghenshui/cppweeklynews/issues)

感谢`不语`赞助

---

## 资讯

标准委员会动态/ide/编译器信息放在这里

[编译器信息最新动态推荐关注hellogcc公众号 本周更新 2023-01-04 第183期](https://github.com/hellogcc/osdt-weekly/blob/master/weekly-2023/2023-01-04.md)

`TODO fix link then remove this line`

boost::async  review https://github.com/klemens-morgenstern/async

https://www.reddit.com/r/cpp/comments/15l8xju/review_of_proposed_boostasync_begins/

比较集成在ASIO上

## 文章

#### [ cppwinrt is in maintenance mode](https://github.com/microsoft/cppwinrt/issues/1289#issuecomment-1481303844)

感觉cppwinrt还没开发多久，就维护状态了，又引入了新库  https://github.com/microsoft/wil/

说实话，微软总搞这种事，开发一个新技术，让大伙学，还没怎么学明白，换坑，再重新学，和google有一拼

#### [Did you know that C++26 added 'A nice placeholder with no name' ](https://github.com/tip-of-the-week/cpp/blob/master/tips/342.md)


```cpp
auto foo() { return 42; }

int main() {
    auto unused = foo(); // warning in C++23
    auto _ = foo();      // no warning in C++26
}
```

话说，我以前是这么玩的, [std::ignore](https://en.cppreference.com/w/cpp/utility/tuple/ignore)

```cpp
decltype(std::ignore) _;
_ = blahblah();
```


#### [Inside STL: The lists](https://devblogs.microsoft.com/oldnewthing/20230804-00/?p=108547)

介绍链表实现，MSVC和gcc/clang的实现还不太一样, 单向链表都差不多

```cpp
template<typename T>
struct forward_list {
    forward_list_node<T>* head;
};

template<typename T>
struct forward_list_node {
    forward_list_node<T>* next;
    T value;
};

```

双向链表，有个边界判定问题

```cpp
template<typename T>
struct list {
    list_node_base<T> head; // or "list_node_base<T>* head;"
    size_t size;
};

template<typename T>
struct list_node_base {
    list_node<T>* next;
    list_node<T>* prev;
};

template<typename T>
struct list_node : list_node_base<T> {
    T value;
};
```

可以有个dummy node来管理开头结尾，也可不用，多一个内存分配，这也是msvc需要注意的地方，list构造可能抛异常


#### [Inside STL: The map, set, multimap, and multiset](https://devblogs.microsoft.com/oldnewthing/20230807-00/?p=108562)

基本结构就这样
```cpp
struct tree {
    node_base header; // or "node_base* header;"
    size_t size;
};

struct node_base {
    node_base* parent;
    node_base* left;
    node_base* right;
};

struct node : node_base {
    bool color; // red or black
    payload data;
};
```

#### [Five Advanced Initialization Techniques in C++: From reserve() to piecewise_construct and More.](https://www.cppstories.com/2023/five-adv-init-techniques-cpp/)

介绍几种高效的用法，比如`vector` `reserve` + `emplace_back`，这种大家都知道，代码就不贴了

lambda 捕获优化

```cpp
auto result = std::find_if(vs.begin(), vs.end(),
        [&prefix](const std::string& s) {
            return s == prefix + "bar"s; 
        }
    );

```
这种使用捕获用法，每次都要生成对象，效率低下，需要改成

```cpp
result = std::find_if(vs.begin(), vs.end(), 
        [savedString = prefix + "bar"s](const std::string& s) { 
            return s == savedString; 
        }
    );
```

这样，避免每次lambda都构造

`unique_ptr`优化 `make_unique_for_overwrite`，有时候你想用`unique_ptr`管理 buffer，但没有必要清零，可以用这个接口，类似`string`的 `resize_for_overwrite`

```cpp
auto ptr = std::make_unique_for_overwrite<int[]>(1000);
```

pair/tuple优化 `piecewise_construct` `forward_as_tuple`

```cpp
// 1
std::cout << "regular: \n";
std::pair<MyType, MyType> p { MyType{"one", 1}, MyType{"two", 2}};

// 2
std::cout << "piecewise + forward: \n";
std::pair<MyType, MyType>p2(std::piecewise_construct,
            std::forward_as_tuple("one", 1),
            std::forward_as_tuple("two", 2));

```

起到一个就地构造的效果，类似emplace_back

对于map来说，这种也能用

```cpp
#include <string>
#include <map>

struct Key {
    Key(int a, int b) : sum(a + b) {}
    int sum;
    bool operator<(const Key& other) const { 
        return sum < other.sum; 
    }
};

struct Value {
    Value(const std::string& s, double d) : name(s), data(d) {}
    std::string name;
    double data;
};

int main() {
    std::map<Key, Value> myMap;

    // doesn't compile: ambiguous
    // myMap.emplace(3, 4, "example", 42.0);

    // works:
    myMap.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(3, 4),  
        std::forward_as_tuple("example", 42.0) 
    );
}

```
#### [Fun with quadratic pack-expansions](https://quuxplusone.github.io/blog/2023/08/05/quadratic-pack-expansions/)

```c++
consteval bool all_of(const auto& f, const auto&... xs) {
  return (f(xs) && ...);
}

consteval bool contains(const auto& n, const auto&... hs) {
  return ((hs == n) || ...);
}

consteval int count(const auto& n, const auto&... hs) {
  return (0 + ... + (hs == n));
}

static_assert(count(1, 3,1,4,1,6) == 2);
static_assert(count(2, 3,1,4,1,6) == 0);
```

这都很常规

类似的，可以写个判断重复

```cpp
consteval bool has_any_duplicates() { return false; }
consteval bool has_any_duplicates(const auto& n, const auto&... hs) {
  return ((n == hs) || ...) || has_any_duplicates(hs...);
}

static_assert(has_any_duplicate(3,1,4,1,6));
static_assert(!has_any_duplicate(2,7,1,8,3));
static_assert(has_any_duplicate(9,9,9));
static_assert(!has_any_duplicate(9));
static_assert(!has_any_duplicate());
```

有点递归了，感觉和count有点像？用count改写

```cpp
constexpr auto has_duplicate_of(const auto& value) {
  return [&](const auto&... hs) {
    return count(value, hs...) >= 2;
  };
}
consteval bool has_any_duplicates(const auto&... hs) {
  return (has_duplicate_of(hs)(hs...) || ...);
}
```

再简化一下,不用 has_duplicate_of

```cpp
consteval bool has_any_duplicates(const auto&... hs) {
  return ((count(hs, hs...) >= 2) || ...);
}
```

不用count再简化一下

```cpp
consteval bool has_any_duplicates(const auto&... hs) {
  return ([&](const auto& n) { return (0 + ... + (hs == n)) >= 2; }(hs) || ...);
}
```

还有优化空间！ 参数n可以优化

```cpp
consteval bool has_any_duplicates(const auto&... hs) {
  return ([&,&n=hs]{ return (0 + ... + (hs == n)) >= 2; }() || ...);
}
```
#### [A case in optimizing auto-vectorized code](https://oliora.github.io/2023/08/07/Optimizing-auto-vectorized-code.html)

手把手教你写SIMD代码。看晕了 代码在这里https://github.com/oliora/habr-switches-perf-test


#### [Inside STL: The unordered_map, unordered_set, unordered_multimap, and unordered_multiset](https://devblogs.microsoft.com/oldnewthing/20230808-00/?p=108572)

hashtable的内存结构，基本就这样

```cpp
struct hashtable{
    using hint = std::list<payload>::iterator;

    std::list<payload> list;
    std::vector<hint> buckets;
};
```

开链在现在的硬件看来已经证明是缓存不友好的了，flatmap可以解决这一点

## 视频

#### [C++ Weekly ](https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw)

`TODO fix link then remove this line`

## 开源项目需要人手

- [asteria](https://github.com/lhmouse/asteria) 一个脚本语言，可嵌入，长期找人，希望胖友们帮帮忙，也可以加群384042845和作者对线
- [Unilang](https://github.com/linuxdeepin/unilang) deepin的一个通用编程语言，点子有点意思，也缺人，感兴趣的可以github讨论区或者deepin论坛看一看。这里也挂着长期推荐了
- [gcc-mcf](https://gcc-mcf.lhmouse.com/) 懂的都懂


## 新项目介绍/版本更新

## 工作招聘

---



[本文永久链接](https://wanghenshui.github.io/cppweeklynews/posts/126.html)

如果有疑问评论最好在上面链接到评论区里评论，这样方便搜索，微信公众号有点封闭/知乎吞评论
